(("undefined"!=typeof globalThis?globalThis:self)["makoChunk_@ant-design/x"]=("undefined"!=typeof globalThis?globalThis:self)["makoChunk_@ant-design/x"]||[]).push([["9ff1d4aa"],{"9ff1d4aa":function(e,a,n){"use strict";n.d(a,"__esModule",{value:!0}),n.d(a,"texts",{enumerable:!0,get:function(){return t;}}),n("7015eb76");let t=[{value:"The ",paraId:0},{value:"components",paraId:0},{value:" property allows you to replace standard HTML tags with custom React components.",paraId:0},{value:"import React from 'react';\nimport { XMarkdown } from '@ant-design/x-markdown';\n\nconst CustomHeading = ({ children, ...props }) => (\n  <h1 style={{ color: '#1890ff' }} {...props}>\n    {children}\n  </h1>\n);\n\nconst App = () => <XMarkdown content=\"# Hello World\" components={{ h1: CustomHeading }} />;\n",paraId:1,tocIndex:0},{value:"// \u274C Bad: Creates new component on every render\n<XMarkdown components={{ h1: (props) => <h1 {...props} /> }} />;\n\n// \u2705 Good: Use predefined component\nconst Heading = (props) => <h1 {...props} />;\n<XMarkdown components={{ h1: Heading }} />;\n",paraId:2,tocIndex:2},{value:'const StaticContent = React.memo(({ children }) => <div className="static">{children}</div>);\n',paraId:3,tocIndex:3},{value:"XMarkdown will pass the ",paraId:4,tocIndex:4},{value:"streamStatus",paraId:4,tocIndex:4},{value:" prop to components by default, indicating whether the component is closed, which is useful for handling streaming rendering.",paraId:4,tocIndex:4},{value:"const StreamingComponent = ({ streamStatus, children }) => {\n  if (streamStatus === 'loading') {\n    return <div className=\"loading\">Loading...</div>;\n  }\n  return <div>{children}</div>;\n};\n",paraId:5,tocIndex:5},{value:"Components support two data fetching methods: directly parsing data from Markdown, or initiating network requests independently.",paraId:6,tocIndex:6},{value:"const UserCard = ({ domNode, streamStatus }) => {\n  const [user, setUser] = useState(null);\n  const username = domNode.attribs?.['data-username'];\n\n  useEffect(() => {\n    if (username && streamStatus === 'done') {\n      fetch(`/api/users/${username}`)\n        .then((r) => r.json())\n        .then(setUser);\n    }\n  }, [username, streamStatus]);\n\n  if (!user) return <div>Loading...</div>;\n\n  return (\n    <div className=\"user-card\">\n      <img src={user.avatar} alt={user.name} />\n      <span>{user.name}</span>\n    </div>\n  );\n};\n",paraId:7,tocIndex:7},{value:"Tag",paraId:8,tocIndex:9},{value:"Component Name",paraId:8,tocIndex:9},{value:"a",paraId:8,tocIndex:9},{value:"a",paraId:8,tocIndex:9},{value:"h1-h6",paraId:8,tocIndex:9},{value:"h1-h6",paraId:8,tocIndex:9},{value:"p",paraId:8,tocIndex:9},{value:"p",paraId:8,tocIndex:9},{value:"img",paraId:8,tocIndex:9},{value:"img",paraId:8,tocIndex:9},{value:"table",paraId:8,tocIndex:9},{value:"table",paraId:8,tocIndex:9},{value:"ul/ol/li",paraId:8,tocIndex:9},{value:"ul/ol/li",paraId:8,tocIndex:9},{value:"code/pre",paraId:8,tocIndex:9},{value:"code/pre",paraId:8,tocIndex:9},{value:"// Support any custom tags\n<XMarkdown\n  components={{\n    'my-component': MyComponent,\n    'user-card': UserCard,\n  }}\n/>\n",paraId:9,tocIndex:10},{value:"Property",paraId:10,tocIndex:11},{value:"Description",paraId:10,tocIndex:11},{value:"Type",paraId:10,tocIndex:11},{value:"Default",paraId:10,tocIndex:11},{value:"domNode",paraId:10,tocIndex:11},{value:"Component DOM node from html-react-parser, containing parsed DOM node information",paraId:10,tocIndex:11},{value:"DOMNode",paraId:10,tocIndex:11},{value:"-",paraId:10,tocIndex:11},{value:"streamStatus",paraId:10,tocIndex:11},{value:"Streaming rendering supports two states: ",paraId:10,tocIndex:11},{value:"loading",paraId:10,tocIndex:11},{value:" indicates content is being loaded, ",paraId:10,tocIndex:11},{value:"done",paraId:10,tocIndex:11},{value:" indicates loading is complete. Currently only supports HTML format and fenced code blocks. Since indented code has no clear end marker, it always returns ",paraId:10,tocIndex:11},{value:"done",paraId:10,tocIndex:11},{value:" status",paraId:10,tocIndex:11},{value:"'loading' | 'done'",paraId:10,tocIndex:11},{value:"-",paraId:10,tocIndex:11},{value:"children",paraId:10,tocIndex:11},{value:"Content wrapped in the component, containing the text content of DOM nodes",paraId:10,tocIndex:11},{value:"React.ReactNode",paraId:10,tocIndex:11},{value:"-",paraId:10,tocIndex:11},{value:"rest",paraId:10,tocIndex:11},{value:"Component properties, supports all standard HTML attributes (such as ",paraId:10,tocIndex:11},{value:"href",paraId:10,tocIndex:11},{value:", ",paraId:10,tocIndex:11},{value:"title",paraId:10,tocIndex:11},{value:", ",paraId:10,tocIndex:11},{value:"className",paraId:10,tocIndex:11},{value:", etc.) and custom data attributes",paraId:10,tocIndex:11},{value:"Record<string, any>",paraId:10,tocIndex:11},{value:"-",paraId:10,tocIndex:11},{value:"When block-level HTML tags contain empty lines (\\n\\n) internally, the Markdown parser treats empty lines as the start of new paragraphs, thereby interrupting recognition of the original HTML block. This causes closing tags to be incorrectly parsed as inline HTML or plain text, ultimately breaking the tag structure.",paraId:11,tocIndex:13},{value:"Example Problem:",paraId:12,tocIndex:13},{value:"Input Markdown:",paraId:13,tocIndex:13},{value:"<think>\nThis is thinking content\n\nThe thinking content contains empty lines </think>\n\nThis is main content\n",paraId:14,tocIndex:13},{value:"Incorrect Output:",paraId:15,tocIndex:13},{value:"<think>\n  This is thinking content\n\n  <p>The thinking content contains empty lines</p>\n  <p>This is main content</p>\n</think>\n",paraId:16,tocIndex:13},{value:"Root Cause:",paraId:17,tocIndex:13},{value:" According to ",paraId:17,tocIndex:13},{value:"CommonMark",paraId:17,tocIndex:13},{value:" specification, HTML block recognition depends on strict formatting rules. Once two consecutive line breaks (i.e., empty lines) appear inside an HTML block and do not meet specific HTML block type continuation conditions (such as ",paraId:17,tocIndex:13},{value:"<div>",paraId:17,tocIndex:13},{value:", ",paraId:17,tocIndex:13},{value:"<pre>",paraId:17,tocIndex:13},{value:", etc.), the parser will terminate the current HTML block and process subsequent content as Markdown paragraphs.",paraId:17,tocIndex:13},{value:"Custom tags (like ",paraId:18,tocIndex:13},{value:"<think>",paraId:18,tocIndex:13},{value:' ) are typically not recognized as "paragraph-spanning" HTML block types, making them highly susceptible to empty line interference.',paraId:18,tocIndex:13},{value:"Solutions:",paraId:19,tocIndex:13},{value:"Option 1",paraId:20,tocIndex:13},{value:": Remove all empty lines inside tags",paraId:20,tocIndex:13},{value:"<think>\nThis is thinking content\nThe thinking content has no empty lines\n</think>\n",paraId:21,tocIndex:13},{value:"Option 2",paraId:22,tocIndex:13},{value:": Add empty lines before, after, and inside HTML tags to make them independent blocks",paraId:22,tocIndex:13},{value:"<think>\n\nThis is thinking content\n\nThe thinking content contains empty lines\n\n</think>\n",paraId:23,tocIndex:13}];}}]);
//# sourceMappingURL=9ff1d4aa-async.98447f16.js.map